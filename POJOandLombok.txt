POJO + Lombok Optimization (Cucumber + Java)
1ï¸âƒ£ Why Lombok in Automation Frameworks?

Without Lombok âŒ

Boilerplate getters/setters
Constructors
Equals / HashCode

With Lombok âœ…
âœ” Cleaner POJOs
âœ” Less code
âœ” Faster development
âœ” More readable step definitions

2ï¸âƒ£ Add Lombok Dependency
Maven
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <version>1.18.30</version>
    <scope>provided</scope>
</dependency>


ğŸ“Œ Also enable Annotation Processing in IDE.

3ï¸âƒ£ Lombok-Optimized POJOs (Nested JSON)
Address POJO
import lombok.*;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Address {
    private String city;
    private String zip;
    private String country;
}

User POJO
import lombok.*;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class User {
    private String name;
    private String role;
    private Address address;
}

Request Wrapper
import lombok.*;
import java.util.List;

@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
public class UserRequest {
    private List<User> users;
}


âœ” Getters/Setters auto-generated
âœ” Clean code
âœ” Immutable option available

4ï¸âƒ£ Feature File (Multiple Rows DataTable)
Scenario: Create multiple users with Lombok
  Given user provides multiple user details
    | name | role  | city   | zip   | country |
    | John | Admin | London | 12345 | UK      |
    | Mike | User  | Berlin | 54321 | Germany |

5ï¸âƒ£ Step Definition â€“ Lombok + Builder Pattern
@Given("user provides multiple user details")
public void user_provides_multiple_user_details(DataTable dataTable) {

    List<Map<String, String>> rows = dataTable.asMaps();

    List<User> users = rows.stream()
            .map(row -> User.builder()
                    .name(row.get("name"))
                    .role(row.get("role"))
                    .address(Address.builder()
                            .city(row.get("city"))
                            .zip(row.get("zip"))
                            .country(row.get("country"))
                            .build())
                    .build())
            .toList();

    UserRequest request = UserRequest.builder()
            .users(users)
            .build();

    response = given()
            .contentType(ContentType.JSON)
            .body(request)
            .post("/users/bulk");
}


ğŸ”¥ This is interview GOLD

6ï¸âƒ£ Generated JSON (Automatically)
{
  "users": [
    {
      "name": "John",
      "role": "Admin",
      "address": {
        "city": "London",
        "zip": "12345",
        "country": "UK"
      }
    },
    {
      "name": "Mike",
      "role": "User",
      "address": {
        "city": "Berlin",
        "zip": "54321",
        "country": "Germany"
      }
    }
  ]
}

7ï¸âƒ£ Why Builder Pattern is Preferred (Interview Trap)

âŒ Constructors break when fields increase
âŒ Setters allow invalid states

âœ” Builder:

Readable
Order-independent
Safe for optional fields
Perfect for JSON payloads

8ï¸âƒ£ Advanced Lombok Options (Lead Level)
Immutable POJO
@Value
@Builder
public class User {
    String name;
    String role;
    Address address;
}


âœ” Thread-safe
âœ” Ideal for parallel execution

Exclude Fields from JSON
@JsonIgnore
private String internalId;

Default Values
@Builder.Default
private String role = "User";

9ï¸âƒ£ Common Lombok Pitfalls

âŒ Forgetting no-args constructor (Cucumber needs it sometimes)
âŒ IDE annotation processing disabled
âŒ Using @Data for entities needing immutability

ğŸ”Ÿ Interview One-Liner

We use Lombok with builder-based POJOs to eliminate boilerplate code and cleanly map Cucumber DataTables into nested JSON payloads for RestAssured APIs.

ğŸ”¥ Lead-Level Closing Statement

Lombok combined with the builder pattern gives us clean, immutable, and scalable POJO models that work seamlessly across UI and API automation while supporting complex nested payloads.

-------------------------------------------------------------------------------------------------------------------------------------------------------------

Lombok Annotations â€“ Significance & Sequence
1ï¸âƒ£ @Data
ğŸ”¹ What it Does

Generates all of the following automatically:

Getters for all fields

Setters for non-final fields

toString()

equals() & hashCode()

RequiredArgsConstructor

@Data
public class User {
    private String name;
    private String role;
}

ğŸ”¹ When to Use

âœ” DTOs / POJOs
âœ” API payload objects
âœ” Cucumber DataTable mapping

âš ï¸ Caution

Not recommended for entities or immutable objects

Generates setters â†’ mutable state

2ï¸âƒ£ @Getter / @Setter
ğŸ”¹ What they Do

Generate getters/setters individually.

@Getter
@Setter
public class User {
    private String name;
}

ğŸ”¹ When to Use

âœ” When you want control
âœ” Avoid full @Data

3ï¸âƒ£ @NoArgsConstructor
ğŸ”¹ What it Does

Creates a no-argument constructor.

@NoArgsConstructor
public class User {}

ğŸ”¹ Why Important

âœ” Required by:

Cucumber DataTable

Jackson (JSON serialization/deserialization)

Reflection-based frameworks

4ï¸âƒ£ @AllArgsConstructor
ğŸ”¹ What it Does

Creates a constructor with all fields as parameters.

@AllArgsConstructor
public class User {
    private String name;
    private String role;
}

ğŸ”¹ When to Use

âœ” Manual object creation
âœ” Test data setup

5ï¸âƒ£ @Builder â­ (Most Important)
ğŸ”¹ What it Does

Generates Builder pattern.

@Builder
public class User {
    private String name;
    private String role;
}

ğŸ”¹ Why We Use It

âœ” Clean object creation
âœ” Avoid constructor overloads
âœ” Order-independent
âœ” Perfect for nested JSON

User.builder()
    .name("John")
    .role("Admin")
    .build();

6ï¸âƒ£ @Value (Immutable Objects)
ğŸ”¹ What it Does

Makes class final

Fields private & final

No setters

Generates getters, equals, hashCode, toString

@Value
@Builder
public class User {
    String name;
    String role;
}

ğŸ”¹ When to Use

âœ” Thread-safe objects
âœ” Parallel execution
âœ” Read-only data

7ï¸âƒ£ @EqualsAndHashCode
ğŸ”¹ What it Does

Generates equals() and hashCode().

@EqualsAndHashCode
public class User {}


âœ” Useful for collections & comparisons

8ï¸âƒ£ @ToString
ğŸ”¹ What it Does

Generates toString().

@ToString
public class User {}


âœ” Helpful for logging/debugging

9ï¸âƒ£ @Builder.Default
ğŸ”¹ What it Does

Sets default value when using Builder.

@Builder.Default
private String role = "User";


âœ” Without this, builder ignores default values

ğŸ”¢ Do Lombok Annotations Have to Be in Sequence?
âŒ NO â€” Order Does NOT Matter
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class User {}


â¬‡ï¸ Same as â¬‡ï¸

@Builder
@AllArgsConstructor
@NoArgsConstructor
@Data
public class User {}

ğŸ“Œ Why?

Lombok is annotation-driven

Java compiler processes them independently

ğŸš¨ But There ARE Some Rules (Interview Gold)
â— Rule 1: @Builder + Constructors

If you add custom constructors, builder may break

Prefer:

@Builder
@AllArgsConstructor
@NoArgsConstructor

â— Rule 2: @Value vs @Data
@Data	@Value
Mutable	Immutable
Setters	No setters
Not thread-safe	Thread-safe

âŒ Do NOT use together

â— Rule 3: Framework Compatibility
Framework	Required
Cucumber	@NoArgsConstructor
Jackson	@NoArgsConstructor
REST APIs	@Builder
Parallel tests	@Value
ğŸ§  Interview One-Liner (Very Strong)

Lombok annotations remove boilerplate code by generating constructors, getters, setters, and builders at compile time. The order of annotations does not matter, but choosing the right combination is critical for framework compatibility and thread safety.

âœ… Recommended Combination (Automation Framework)
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class User {}


ğŸ”¥ Clean
ğŸ”¥ Flexible
ğŸ”¥ Interview-safe