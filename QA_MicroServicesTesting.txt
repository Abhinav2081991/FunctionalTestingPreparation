Practical Examples of Microservices Testing (Real-World)

Microservices testing is NOT â€œrun some APIs and doneâ€.
Itâ€™s about testing in layers, controlling blast radius, and catching failures early.

ğŸ§± Typical Microservices Architecture (Context)
UI / Mobile
   â†“
API Gateway
   â†“
Order Service â”€â”€â–¶ Payment Service â”€â”€â–¶ Notification Service
   â†“
Inventory Service


Each service:

Independently deployed

Own database

Own CI pipeline

ğŸ§ª 1ï¸âƒ£ Unit Testing (Service-Internal Logic)
ğŸ¯ Goal

Test business logic inside a single service, no network, no DB.

ğŸ”¹ Example: Order Service â€“ Price Calculation
@Test
void shouldCalculateOrderTotal() {
    OrderService service = new OrderService();
    double total = service.calculateTotal(100, 2, 10);
    assertEquals(190, total);
}


âœ” Fast
âœ” No dependencies
âœ” Uses mocks/stubs

ğŸ”¹ What to Mock?

Repositories

External API clients

Message producers

ğŸ“Œ Mockito is perfect here

ğŸ§ª 2ï¸âƒ£ Contract Testing (Consumer â†” Provider)
ğŸ¯ Goal

Ensure API agreement between services.

ğŸ”¹ Example: Order â†’ Payment
Consumer Expectation
{
  "status": "SUCCESS",
  "transactionId": "string"
}

Pact Consumer Test
@Pact(consumer = "order-service")
RequestResponsePact paymentContract(PactDslWithProvider builder) {
    return builder
        .uponReceiving("payment request")
        .path("/pay")
        .method("POST")
        .willRespondWith()
        .status(200)
        .body(new PactDslJsonBody()
              .stringType("status")
              .stringType("transactionId"))
        .toPact();
}

Provider Verification

Payment service must satisfy this contract in CI.

âœ” Prevents breaking changes
âœ” No full environment needed
âœ” CI-safe

ğŸ“Œ This is NON-negotiable in microservices

ğŸ§ª 3ï¸âƒ£ API Integration Testing (Service + DB)
ğŸ¯ Goal

Validate service behavior with its real DB and config.

ğŸ”¹ Example: Inventory Service
given()
  .body(itemPayload)
.when()
  .post("/inventory")
.then()
  .statusCode(201)
  .body("itemId", notNullValue());


âœ” Real DB (Docker/Testcontainers)
âœ” No downstream services

ğŸ”¹ Tools

Rest Assured

Testcontainers

H2/Postgres container

ğŸ§ª 4ï¸âƒ£ Message/Event Testing (Kafka / RabbitMQ)
ğŸ¯ Goal

Validate asynchronous communication.

ğŸ”¹ Example: Order Created Event
@Test
void shouldPublishOrderCreatedEvent() {
    orderService.createOrder(order);
    ConsumerRecord<String, OrderEvent> record = kafkaConsumer.poll();
    assertEquals("ORDER_CREATED", record.value().getType());
}


âœ” Event schema correctness
âœ” Message published once
âœ” Retry/idempotency checks

ğŸ“Œ Often missed by junior teams

ğŸ§ª 5ï¸âƒ£ Component Testing (Service + Real Dependencies)
ğŸ¯ Goal

Test a service with real downstream services but controlled.

ğŸ”¹ Example

Order Service + Payment Service (real)
Inventory mocked

docker-compose up order payment


âœ” Validates service collaboration
âœ” Smaller scope than E2E

ğŸ§ª 6ï¸âƒ£ End-to-End Testing (Critical Business Flow)
ğŸ¯ Goal

Validate one or two critical flows only.

ğŸ”¹ Example: Place Order Flow
Create Order â†’ Pay â†’ Reduce Inventory â†’ Send Email

given()
  .body(order)
.when()
  .post("/orders")
.then()
  .statusCode(200);


âœ” Very limited
âœ” High maintenance
âŒ Do NOT overdo

ğŸ“Œ 5â€“10 E2E tests max in mature orgs

ğŸ§ª 7ï¸âƒ£ Resilience & Failure Testing
ğŸ¯ Goal

Verify system behavior under failures.

ğŸ”¹ Example: Payment Down
when(paymentClient.pay()).thenThrow(new TimeoutException());


Expect:

Order marked PENDING

Retry scheduled

No data corruption

âœ” Circuit breaker behavior
âœ” Retry logic
âœ” Fallbacks

ğŸ§ª 8ï¸âƒ£ Performance Testing (Service-Level)
ğŸ¯ Goal

Test each service independently.

ğŸ”¹ Example

Order Service handles 1k RPS

Payment handles 500 RPS

Tools:

JMeter

Gatling

k6

ğŸ§ª 9ï¸âƒ£ Security Testing (API Level)
ğŸ¯ Goal

Validate auth, roles, token propagation.

ğŸ”¹ Example
given()
  .header("Authorization", "Bearer invalid")
.when()
  .get("/orders")
.then()
  .statusCode(401);


âœ” JWT expiry
âœ” Role-based access
âœ” Service-to-service auth

ğŸ§ª ğŸ”Ÿ Data Consistency & Idempotency
ğŸ¯ Goal

Ensure eventual consistency.

ğŸ”¹ Example: Duplicate Order Request
POST /orders (same idempotency key)


Expected:

No duplicate order

Same response returned

âœ” Critical in distributed systems

ğŸ§  Microservices Test Pyramid (Practical)
        E2E (very few)
   Component Tests
 Contract Tests (mandatory)
 Integration Tests
 Unit Tests (most)

ğŸ§  Key Mistakes Teams Make
Mistake	Fix
Too many E2E tests	Push down to contracts
Over-mocking	Use contracts
No async testing	Test events explicitly
Shared DB	Strict DB per service
ğŸ† Interview-Ready Summary

â€œIn microservices, testing shifts left.
We rely heavily on unit + contract tests, keep E2E minimal, and test resilience, events, and contracts as first-class citizens.â€