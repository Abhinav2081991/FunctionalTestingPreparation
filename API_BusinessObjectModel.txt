What Is Business Object Model (BOM) in API Testing?

Business Object Model =
Represent API requests and responses as domain/business objects, not raw JSON strings.

Why BOM?

âœ” Readable tests
âœ” Reusable request builders
âœ” Type-safe response parsing
âœ” Easy API chaining
âœ” Clean separation of concerns

ğŸ—ï¸ Example Use Case (Quantifind-style API)

API: Get Entity Risk Profile

GET /quantifind/v1/entities/{entityId}

1ï¸âƒ£ Define Business Request Object
ğŸ”¹ EntityRiskRequest.java
import lombok.Builder;
import lombok.Data;

@Data
@Builder
public class EntityRiskRequest {
    private String entityId;
    private String entityType;
    private boolean includeHistory;
}


âœ” This represents business intent, not HTTP mechanics.

2ï¸âƒ£ Define Business Response Object
ğŸ”¹ EntityRiskResponse.java
import lombok.Data;

@Data
public class EntityRiskResponse {
    private String requestId;
    private String status;
    private Entity entity;
}

@Data
public class Entity {
    private String entityId;
    private String entityType;
    private String name;
    private RiskProfile riskProfile;
}

@Data
public class RiskProfile {
    private int overallRiskScore;
    private String riskLevel;
}

3ï¸âƒ£ API Client Layer (HTTP abstraction)
ğŸ”¹ QuantifindApiClient.java
import static io.restassured.RestAssured.given;

public class QuantifindApiClient {

    private final String baseUrl;

    public QuantifindApiClient(String baseUrl) {
        this.baseUrl = baseUrl;
    }

    public EntityRiskResponse getEntityRisk(EntityRiskRequest request) {

        return given()
                .baseUri(baseUrl)
                .queryParam("includeHistory", request.isIncludeHistory())
        .when()
                .get("/quantifind/v1/entities/{id}", request.getEntityId())
        .then()
                .statusCode(200)
                .extract()
                .as(EntityRiskResponse.class);   // ğŸ”¥ JSON â†’ Business Object
    }
}


âœ” Raw JSON never leaks into tests
âœ” Jackson handles parsing automatically

4ï¸âƒ£ Test Using Business Objects (Clean & Expressive)
ğŸ”¹ EntityRiskTest.java
@Test
public void shouldReturnHighRiskEntity() {

    EntityRiskRequest request =
            EntityRiskRequest.builder()
                    .entityId("ENT-458921")
                    .includeHistory(true)
                    .build();

    QuantifindApiClient client =
            new QuantifindApiClient("http://localhost:8080");

    EntityRiskResponse response =
            client.getEntityRisk(request);

    assertEquals("SUCCESS", response.getStatus());
    assertEquals("HIGH", response.getEntity().getRiskProfile().getRiskLevel());
    assertTrue(response.getEntity().getRiskProfile().getOverallRiskScore() > 70);
}

5ï¸âƒ£ API Chaining Using Business Objects
String entityId =
        response.getEntity().getEntityId();

EntityRiskRequest followUpRequest =
        EntityRiskRequest.builder()
                .entityId(entityId)
                .includeHistory(false)
                .build();


âœ” No JSON path
âœ” No string parsing
âœ” Fully type-safe

6ï¸âƒ£ BOM + WireMock (Perfect Match)
wiremock.stubFor(get(urlEqualTo("/quantifind/v1/entities/ENT-458921"))
        .willReturn(okJson(objectMapper.writeValueAsString(
                EntityRiskResponseMother.highRiskEntity()
        ))));


âœ” Same business object used for:

Test data

WireMock stubs

Assertions

7ï¸âƒ£ BOM + Cucumber ScenarioContext
scenarioContext.set("ENTITY_RESPONSE", response);

EntityRiskResponse stored =
        scenarioContext.get("ENTITY_RESPONSE");


âœ” Clean API chaining across steps

ğŸ§  Architecture Summary (Interview Gold)
Test Layer
   â†“
Business Objects (Request / Response)
   â†“
API Client (Rest Assured)
   â†“
HTTP Layer

ğŸ”¥ When This Model Is Used in Real Projects

âœ” Backend-only systems
âœ” AI / Risk engines
âœ” Microservices
âœ” Contract testing
âœ” CI-safe API automation

ğŸ¯ Interview One-Liner

â€œWe use a Business Object Model to encapsulate API requests and responses, enabling type-safe parsing, reusable request builders, cleaner assertions, and stable API chaining without relying on raw JSON manipulation.â€


