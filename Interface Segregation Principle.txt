Perfect â€” now weâ€™ll convert the refactored ISP-compliant Page architecture into a clean, production-ready Cucumber Step Architecture.

Iâ€™ll do this incrementally, exactly how you should design it in real projects and explain it in interviews.

ğŸ¯ Target Architecture (What We Are Building)
features/
 â””â”€â”€ login.feature

stepdefinitions/
 â””â”€â”€ LoginSteps.java

context/
 â””â”€â”€ TestContext.java

pages/
 â”œâ”€â”€ BasePage.java
 â”œâ”€â”€ LoginPage.java
 â””â”€â”€ PaymentPage.java

actions/
 â”œâ”€â”€ ClickActions.java
 â”œâ”€â”€ TypeActions.java
 â”œâ”€â”€ AlertActions.java
 â””â”€â”€ impl/

wait/
 â”œâ”€â”€ WaitStrategy.java
 â””â”€â”€ impl/


âœ” SOLID
âœ” ISP-compliant
âœ” PicoContainer-friendly
âœ” Parallel-safe

STEP 1ï¸âƒ£ Feature File (Pure Business Language)
Feature: Login

  Scenario: Successful login
    Given I am on the login page
    When I login with username "abhinav"
    Then I should be logged in successfully


âœ” No Selenium
âœ” No waits
âœ” No implementation leakage

STEP 2ï¸âƒ£ TestContext (Single Wiring Point)
ğŸ“Œ This is CRITICAL â€” avoids DI errors you faced earlier
package core.context;

import core.wait.*;
import core.wait.impl.*;
import core.actions.*;
import core.actions.impl.*;
import core.drivers.DriverManager;
import org.openqa.selenium.WebDriver;

public class TestContext {

    private final WebDriver driver;

    private final ClickActions clickActions;
    private final TypeActions typeActions;
    private final AlertActions alertActions;

    public TestContext() {
        this.driver = DriverManager.getDriver();

        WaitStrategy visibleWait = new VisibleWaitStrategy();
        WaitStrategy clickableWait = new ClickableWaitStrategy();

        this.clickActions = new SeleniumClickActions(clickableWait);
        this.typeActions = new SeleniumTypeActions(visibleWait);
        this.alertActions = new SeleniumAlertActions(driver);
    }

    public WebDriver getDriver() {
        return driver;
    }

    public ClickActions getClickActions() {
        return clickActions;
    }

    public TypeActions getTypeActions() {
        return typeActions;
    }

    public AlertActions getAlertActions() {
        return alertActions;
    }
}


âœ… Everything created once per scenario
âœ… PicoContainer can instantiate this automatically
âœ… No circular dependency

STEP 3ï¸âƒ£ Page Object (Already ISP-Clean)
LoginPage
package pages;

import core.actions.ClickActions;
import core.actions.TypeActions;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.support.FindBy;

public class LoginPage extends BasePage {

    private final ClickActions clickActions;
    private final TypeActions typeActions;

    public LoginPage(WebDriver driver,
                     ClickActions clickActions,
                     TypeActions typeActions) {
        super(driver);
        this.clickActions = clickActions;
        this.typeActions = typeActions;
    }

    @FindBy(id = "username")
    WebElement username;

    @FindBy(id = "login")
    WebElement loginBtn;

    public void login(String user) {
        typeActions.type(username, user);
        clickActions.click(loginBtn);
    }
}


âœ” Page has only what it needs
âœ” No waits, no driver creation

STEP 4ï¸âƒ£ Step Definitions (Thin & Clean)
LoginSteps.java
package stepdefinitions;

import core.context.TestContext;
import io.cucumber.java.en.*;
import pages.LoginPage;

public class LoginSteps {

    private final LoginPage loginPage;

    // PicoContainer injects TestContext automatically
    public LoginSteps(TestContext context) {
        this.loginPage = new LoginPage(
                context.getDriver(),
                context.getClickActions(),
                context.getTypeActions()
        );
    }

    @Given("I am on the login page")
    public void i_am_on_login_page() {
        context.getDriver().get("https://example.com/login");
    }

    @When("I login with username {string}")
    public void i_login(String user) {
        loginPage.login(user);
    }

    @Then("I should be logged in successfully")
    public void i_should_be_logged_in() {
        // assertion here
    }
}

STEP 5ï¸âƒ£ Why This Architecture Works (Interview Explanation)
ğŸ§  Key Points to Say

â€œStep definitions contain no Selenium logic.
They only coordinate pages.
All technical dependencies are resolved in a TestContext class, which PicoContainer injects per scenario.
Pages depend only on the capabilities they need, following ISP.
This makes steps thin, pages reusable, and the framework parallel-safe.â€

STEP 6ï¸âƒ£ How PicoContainer Knows What to Inject

You already did this right â€” just ensure dependency is present:

<dependency>
  <groupId>io.cucumber</groupId>
  <artifactId>cucumber-picocontainer</artifactId>
  <version>7.x.x</version>
</dependency>


âœ” No zero-arg constructor needed
âœ” Pico uses constructor injection

STEP 7ï¸âƒ£ Parallel Execution Safety

Why this design works in parallel:

Layer	Why Safe
WebDriver	ThreadLocal via DriverManager
TestContext	One per scenario
Pages	Created per scenario
WaitStrategy	Stateless
Actions	Stateless
STEP 8ï¸âƒ£ Anti-Patterns You Have Now Avoided

âŒ StepDefs creating WebDriver
âŒ Pages calling DriverManager
âŒ Static waits
âŒ Fat BasePage
âŒ Circular DI errors

ğŸ¯ Final Interview Summary (Memorize This)

â€œI use a TestContext per scenario to wire WebDriver, waits, and actions.
Step definitions only orchestrate behavior.
Pages depend on small capability interfaces instead of a large BasePage, ensuring ISP.
This structure integrates cleanly with Cucumber PicoContainer and supports parallel execution.â€