Code: Use File directly as request body
import io.restassured.RestAssured;
import java.io.File;

RestAssured.baseURI = "https://reqres.in";

File jsonBody = new File("src/test/resources/payloads/createUser.json");

RestAssured
    .given()
        .header("Content-Type", "application/json")
        .body(jsonBody)
    .when()
        .post("/api/users")
    .then()
        .statusCode(201);


âœ” Rest Assured auto-serializes file
âœ” Clean & readable
âœ” Most commonly used

ğŸ”¹ Option 2: Read JSON as String (When You Need to Modify It)
âœ… Java 8+ (Recommended)
import java.nio.file.Files;
import java.nio.file.Paths;

String body = new String(
        Files.readAllBytes(
            Paths.get("src/test/resources/payloads/createUser.json")
        )
);

RestAssured
    .given()
        .contentType("application/json")
        .body(body)
    .when()
        .post("/api/users");


âœ” Needed if you want replace values dynamically

ğŸ” Example: Dynamic replacement
body = body.replace("Abhinav", "DynamicUser");

ğŸ”¹ Option 3: Read JSON from Classpath (CI-Friendly â­)

ğŸ‘‰ BEST PRACTICE for Jenkins / GitHub Actions

import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import org.apache.commons.io.IOUtils;

InputStream is = getClass()
        .getClassLoader()
        .getResourceAsStream("payloads/createUser.json");

String body = IOUtils.toString(is, StandardCharsets.UTF_8);

RestAssured
    .given()
        .contentType("application/json")
        .body(body)
    .when()
        .post("/api/users");


âœ” Works in JAR / Docker / CI
âœ” Avoids absolute paths
âœ” Production-grade

ğŸ”¹ Option 4: Using Jackson (JSON â†’ POJO â†’ JSON)
ğŸ“Œ POJO
public class User {
    private String name;
    private String job;

    // getters & setters
}

ğŸ“Œ Code
ObjectMapper mapper = new ObjectMapper();

User user = mapper.readValue(
    new File("src/test/resources/payloads/createUser.json"),
    User.class
);

user.setName("Updated Name");

RestAssured
    .given()
        .contentType(ContentType.JSON)
        .body(user)
    .when()
        .post("/api/users");


âœ” Clean business logic
âœ” Best for large APIs
âœ” Strong typing

ğŸ”¹ Option 5: Parameterized JSON (Hybrid â€“ Real Projects)
ğŸ“„ Template JSON
{
  "name": "{{name}}",
  "job": "{{job}}"
}

ğŸ“Œ Code
String body = Files.readString(
    Paths.get("src/test/resources/payloads/userTemplate.json")
);

body = body
        .replace("{{name}}", "Abhinav")
        .replace("{{job}}", "Lead");

RestAssured
    .given()
        .contentType(ContentType.JSON)
        .body(body)
    .post("/api/users");


âœ” API chaining
âœ” Data-driven tests
âœ” Very popular in contract testing

ğŸ”¹ Option 6: Reusable Utility (Framework-Style â­)
ğŸ“Œ JsonUtil.java
public class JsonUtil {

    public static String readJson(String path) {
        try {
            return new String(Files.readAllBytes(Paths.get(path)));
        } catch (IOException e) {
            throw new RuntimeException("Failed to read JSON: " + path, e);
        }
    }
}

ğŸ“Œ Usage
String body = JsonUtil.readJson(
    "src/test/resources/payloads/createUser.json"
);

RestAssured
    .given()
        .contentType(ContentType.JSON)
        .body(body)
    .post("/api/users");


âœ” Clean
âœ” Maintainable
âœ” Framework-ready

ğŸ§  When to Use What?
Scenario	Best Option
Simple API	File as body
Dynamic values	String / Template
CI/CD pipelines	Classpath
Large framework	POJO / Jackson
Contract testing	File / Template
ğŸ’¡ Interview Tip

â€œIn CI pipelines, I always prefer classpath-based JSON loading to avoid file path issues and to ensure portability.â€