Typical DELETE API Contract
DELETE /users/{id}

Headers:
Authorization: Bearer <token>

Responses:
200 â†’ Deleted successfully (with body)
204 â†’ Deleted successfully (no body)
401 â†’ Unauthorized
404 â†’ Not found

ğŸ”¹ 2ï¸âƒ£ WireMock â€“ DELETE Stub (Success â€“ 204 No Content)
import static com.github.tomakehurst.wiremock.client.WireMock.*;

public static void stubDeleteUserSuccess() {

    stubFor(delete(urlPathMatching("/users/\\d+"))
        .withHeader("Authorization", equalTo("Bearer valid-token"))
        .willReturn(aResponse()
            .withStatus(204)
        )
    );
}


âœ” REST-correct
âœ” Idempotent delete
âœ” Most common real API behavior

ğŸ”¹ 3ï¸âƒ£ WireMock â€“ DELETE with Response Body (200 OK)

Some APIs return confirmation:

public static void stubDeleteUserWithBody() {

    stubFor(delete(urlEqualTo("/users/123"))
        .withHeader("Authorization", equalTo("Bearer valid-token"))
        .willReturn(aResponse()
            .withStatus(200)
            .withHeader("Content-Type", "application/json")
            .withBody(
                "{\n" +
                "  \"id\": 123,\n" +
                "  \"status\": \"DELETED\"\n" +
                "}"
            )
        )
    );
}

ğŸ”¹ 4ï¸âƒ£ WireMock â€“ Unauthorized DELETE (401)
public static void stubDeleteUserUnauthorized() {

    stubFor(delete(urlPathMatching("/users/\\d+"))
        .withHeader("Authorization", absent())
        .willReturn(aResponse()
            .withStatus(401)
            .withHeader("Content-Type", "application/json")
            .withBody("{\"error\":\"Unauthorized\"}")
        )
    );
}

ğŸ”¹ 5ï¸âƒ£ WireMock â€“ User Not Found (404)
public static void stubDeleteUserNotFound() {

    stubFor(delete(urlEqualTo("/users/999"))
        .withHeader("Authorization", equalTo("Bearer valid-token"))
        .willReturn(aResponse()
            .withStatus(404)
            .withHeader("Content-Type", "application/json")
            .withBody("{\"error\":\"User not found\"}")
        )
    );
}

ğŸ”¹ 6ï¸âƒ£ WireMock â€“ Scenario-based DELETE (Idempotency)

Second delete returns 404 (realistic behavior).

stubFor(delete(urlEqualTo("/users/123"))
    .inScenario("Delete User Flow")
    .whenScenarioStateIs(STARTED)
    .willReturn(aResponse().withStatus(204))
    .willSetStateTo("DELETED")
);

stubFor(delete(urlEqualTo("/users/123"))
    .inScenario("Delete User Flow")
    .whenScenarioStateIs("DELETED")
    .willReturn(aResponse()
        .withStatus(404)
        .withBody("{\"error\":\"Already deleted\"}")
    )
);


ğŸ”¥ This is gold-standard contract testing

ğŸ”¹ 7ï¸âƒ£ Rest Assured DELETE Test
RestAssured
    .given()
        .baseUri("http://localhost:7776")
        .header("Authorization", "Bearer valid-token")
    .when()
        .delete("/users/123")
    .then()
        .statusCode(anyOf(is(200), is(204)));

ğŸ”¹ 8ï¸âƒ£ DELETE + JSON Schema Validation (If Body Exists)
Schema (delete_user_response.schema.json)
{
  "type": "object",
  "required": ["id", "status"],
  "properties": {
    "id": { "type": "integer" },
    "status": { "type": "string" }
  }
}

Test
.then()
    .statusCode(200)
    .body(matchesJsonSchemaInClasspath(
        "schemas/delete_user_response.schema.json"
    ));

ğŸ§  Interview-Ready Explanation

â€œWireMock allows us to simulate DELETE operations including authorization, idempotency, and negative scenarios. Combined with Rest Assured and JSON Schema validation, this ensures full consumer-side contract testing.â€

âœ… Best Practices for DELETE in WireMock

	âœ” Prefer 204 No Content
	âœ” Validate headers (auth)
	âœ” Use scenario states
	âœ” Avoid request body
	âœ” Validate idempotency
	âœ” Add negative paths