What is Contract Testing (Quick Reminder)

Contract testing verifies that:

âœ… The consumerâ€™s expectations
match
âœ… The providerâ€™s implementation

Without spinning up the real provider.

ğŸ§© Where WireMock Fits

WireMock is mainly used for:

âœ” Consumer-side contract tests
âœ” Stubbing provider APIs
âœ” Verifying request/response structure
âœ” Simulating edge cases & failures

WireMock does NOT enforce provider verification automatically like Pact â€” but itâ€™s lighter, simpler, and very popular in real projects.

ğŸ—ï¸ Example Architecture
Scenario

Consumer Service: Order Service

Provider Service: Payment Service

Order Service calls:

GET /payments/{orderId}

ğŸªœ Step-by-Step: Contract Testing with WireMock
1ï¸âƒ£ Add WireMock Dependency
Maven
<dependency>
    <groupId>com.github.tomakehurst</groupId>
    <artifactId>wiremock-jre8</artifactId>
    <version>2.35.0</version>
    <scope>test</scope>
</dependency>

2ï¸âƒ£ Define the Contract (Stub)

This is the contract from the consumerâ€™s point of view.

Contract Expectations:

Endpoint exists

Correct HTTP method

Required headers

Response structure & status

WireMock Stub (Java)
import static com.github.tomakehurst.wiremock.client.WireMock.*;

@BeforeAll
static void setup() {
    WireMock.configureFor("localhost", 8089);
    WireMockServer server = new WireMockServer(8089);
    server.start();

    stubFor(get(urlEqualTo("/payments/123"))
        .withHeader("Accept", equalTo("application/json"))
        .willReturn(aResponse()
            .withStatus(200)
            .withHeader("Content-Type", "application/json")
            .withBody("""
                {
                  "orderId": "123",
                  "status": "SUCCESS",
                  "amount": 4500
                }
            """)));
}


ğŸ“Œ This stub is your contract.

3ï¸âƒ£ Call WireMock Instead of Real Provider
Application config (test profile)
payment.service.url=http://localhost:8089

Consumer Code (Order Service)
public PaymentResponse getPayment(String orderId) {
    return restTemplate.getForObject(
        paymentServiceUrl + "/payments/" + orderId,
        PaymentResponse.class
    );
}

4ï¸âƒ£ Write the Contract Test (Consumer Side)
@Test
void shouldFetchPaymentSuccessfully() {

    PaymentResponse response = paymentClient.getPayment("123");

    assertEquals("SUCCESS", response.getStatus());
    assertEquals(4500, response.getAmount());
}


âœ” Confirms consumer works
âœ” Confirms response structure
âœ” No real provider needed

5ï¸âƒ£ Verify Provider Interaction (Optional but Important)

WireMock lets you verify how the API was called.

verify(getRequestedFor(urlEqualTo("/payments/123"))
    .withHeader("Accept", equalTo("application/json")));


This ensures:

Correct endpoint

Correct headers

Correct method

ğŸš¨ Negative Contract Testing (Very Important)
Example: Provider returns 404
stubFor(get(urlEqualTo("/payments/999"))
    .willReturn(aResponse().withStatus(404)));

@Test
void shouldHandlePaymentNotFound() {
    assertThrows(PaymentNotFoundException.class,
        () -> paymentClient.getPayment("999"));
}


âœ” Validates error contracts
âœ” Prevents runtime surprises

ğŸ“ JSON-Based Contract (Best Practice)

Store contracts as JSON files (cleaner + reusable).

src/test/resources/contracts/payment-success.json

{
  "orderId": "123",
  "status": "SUCCESS",
  "amount": 4500
}

.withBodyFile("contracts/payment-success.json")

ğŸ” Provider Validation (Manual but Practical)
How provider team validates:

Run Payment Service locally

Use same WireMock stubs

Compare actual response vs stub

ğŸ‘‰ Many teams integrate this via:

CI pipelines

Regression API tests

ğŸ†š WireMock vs Pact (Interview Gold)
Aspect	WireMock	Pact
Consumer-side mocking	âœ” Yes	âœ” Yes
Provider verification	âŒ Manual	âœ” Automated
Learning curve	â­ Easy	âš  Medium
Flexibility	â­â­â­â­	â­â­â­
Industry adoption	Very High	High

ğŸ‘‰ Real-world truth:

WireMock â†’ fast, pragmatic teams

Pact â†’ strict contract governance

ğŸ§  How to Explain in an Interview

â€œWe perform consumer-driven contract testing using WireMock by stubbing provider APIs based on consumer expectations. These stubs act as contracts and are used during consumer tests. Provider teams validate their APIs against the same contracts to ensure backward compatibility.â€

ğŸ§ª Bonus: Rest Assured + WireMock
given()
    .baseUri("http://localhost:8089")
.when()
    .get("/payments/123")
.then()
    .statusCode(200)
    .body("status", equalTo("SUCCESS"))
    .body("amount", equalTo(4500));

ğŸ§  Summary

âœ” WireMock stubs = consumer contracts
âœ” Fast, isolated testing
âœ” Validates happy & failure paths
âœ” CI-friendly
âœ” Excellent for microservices

If you want next:

ğŸ†š WireMock vs Pact with same example

ğŸ§ª Contract testing in CI/CD

ğŸ”„ Backward compatibility testing

ğŸ§± Schema-based contract validation

ğŸ—ï¸ Spring Cloud Contract alternative