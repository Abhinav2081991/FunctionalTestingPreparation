Advanced WireMock Mocking Features (With Code)
1ï¸âƒ£ Stateful Mocking (Scenario-Based Responses)
ğŸ“Œ Use Case

API behaves differently based on state (order lifecycle, payment flow).

Example

POST /order â†’ CREATED â†’ PAID

stubFor(post(urlEqualTo("/order"))
    .inScenario("Order Lifecycle")
    .whenScenarioStateIs(STARTED)
    .willSetStateTo("CREATED")
    .willReturn(aResponse()
        .withStatus(201)
        .withBody("{ \"status\": \"CREATED\" }")));

stubFor(post(urlEqualTo("/order/pay"))
    .inScenario("Order Lifecycle")
    .whenScenarioStateIs("CREATED")
    .willSetStateTo("PAID")
    .willReturn(aResponse()
        .withStatus(200)
        .withBody("{ \"status\": \"PAID\" }")));


âœ” Simulates real backend workflows
âœ” Perfect for API chaining tests

2ï¸âƒ£ Dynamic Responses with Response Templating
ğŸ“Œ Use Case

Return dynamic values like IDs, timestamps, headers.

Enable Templating
WireMockServer wireMockServer =
    new WireMockServer(options()
        .port(8080)
        .extensions(new ResponseTemplateTransformer(true)));

Example: Generate Dynamic Order ID
stubFor(post(urlEqualTo("/orders"))
    .willReturn(aResponse()
        .withHeader("Content-Type", "application/json")
        .withBody("""
        {
          "orderId": "{{randomValue length=10 type='ALPHANUMERIC'}}",
          "createdAt": "{{now}}"
        }
        """)
        .withTransformers("response-template")));


âœ” Removes hardcoding
âœ” CI-friendly

3ï¸âƒ£ Request Body Matching (Advanced Validation)
ğŸ“Œ Use Case

Mock behavior changes based on payload content.

Exact JSON Match
stubFor(post(urlEqualTo("/payment"))
    .withRequestBody(equalToJson("""
        { "method": "CREDIT_CARD" }
    """))
    .willReturn(ok()));

JSON Path Matching
stubFor(post(urlEqualTo("/payment"))
    .withRequestBody(matchingJsonPath("$.amount", greaterThan("1000")))
    .willReturn(aResponse()
        .withStatus(402)
        .withBody("Payment requires approval")));


âœ” Conditional mocking
âœ” Business-rule simulation

4ï¸âƒ£ Header-Based & Query Param Matching
ğŸ“Œ Use Case

Auth, versioning, locale, feature flags.

stubFor(get(urlPathEqualTo("/users"))
    .withHeader("Authorization", matching("Bearer .*"))
    .withQueryParam("version", equalTo("v2"))
    .willReturn(okJson("{ \"user\": \"premium\" }")));


âœ” Mimics real API gateways

5ï¸âƒ£ Fault Injection (Chaos Testing)
ğŸ“Œ Use Case

Test client resilience, retries, timeouts.

Network Faults
stubFor(get(urlEqualTo("/inventory"))
    .willReturn(aResponse()
        .withFault(Fault.CONNECTION_RESET_BY_PEER)));

Random Delay
stubFor(get(urlEqualTo("/slow-api"))
    .willReturn(aResponse()
        .withFixedDelay(5000)
        .withStatus(200)));


âœ” Retry logic validation
âœ” Circuit breaker testing

6ï¸âƒ£ Rate Limiting Simulation
ğŸ“Œ Use Case

Validate 429 handling.

AtomicInteger counter = new AtomicInteger(0);

stubFor(get(urlEqualTo("/rate-limited"))
    .willReturn(aResponse()
        .withTransformers("response-template")
        .withBody("""
        {{#if (gt (increment) 5)}}
          {{jsonPath request.body '$'}}
        {{/if}}
        """)));


ğŸ‘‰ Better approach (custom transformer):

public class RateLimitTransformer extends ResponseTransformer {

    private static final AtomicInteger COUNT = new AtomicInteger(0);

    @Override
    public Response transform(Request req, Response res, FileSource fs, Parameters p) {
        if (COUNT.incrementAndGet() > 5) {
            return Response.response()
                    .status(429)
                    .body("Too Many Requests")
                    .build();
        }
        return Response.response().status(200).body("OK").build();
    }

    @Override
    public String getName() {
        return "rate-limit-transformer";
    }
}

7ï¸âƒ£ Webhooks & Async Callback Simulation
ğŸ“Œ Use Case

Payment gateways, async notifications.

stubFor(post(urlEqualTo("/payments"))
    .willReturn(aResponse()
        .withStatus(202)
        .withBody("Accepted")));


Later:

stubFor(post(urlEqualTo("/callback"))
    .willReturn(ok()));


âœ” Simulates async systems

8ï¸âƒ£ Proxying to Real Service (Hybrid Mode)
ğŸ“Œ Use Case

Mock unstable dependencies, pass others.

stubFor(any(anyUrl())
    .willReturn(aResponse()
        .proxiedFrom("https://real-api.example.com")));


âœ” Gradual test environment isolation

9ï¸âƒ£ Verify Requests (Behavior Verification)
ğŸ“Œ Use Case

Ensure API was called correctly.

verify(postRequestedFor(urlEqualTo("/orders"))
    .withRequestBody(matchingJsonPath("$.product")));


âœ” Contract validation
âœ” Prevents silent failures

ğŸ”Ÿ Reset & Test Isolation
@AfterEach
void resetMocks() {
    wireMockServer.resetAll();
}


âœ” Clean test state
âœ” Parallel-safe

ğŸ§  Senior-Level Best Practices

âœ” Use WireMock for external dependencies only
âœ” Combine with Rest Assured for client-side assertions
âœ” Prefer Scenario + Templating over static stubs
âœ” Use faults for resilience testing
âœ” Never hardcode dynamic data

ğŸ¯ Interview-Ready Summary

â€œWireMock provides advanced mocking through stateful scenarios, dynamic response templating, conditional request matching, fault injection, and verification, enabling realistic simulation of complex backend behaviors for resilient API testing.â€

If you want next, I can:

ğŸ”¥ Show WireMock + Cucumber integration

ğŸ”¥ Build a rate-limit + retry test

ğŸ”¥ Demonstrate chaos testing with WireMock

ğŸ”¥ Design enterprise mocking strategy

Just say ğŸš€

When Wiremock is used in real time usecases in Rest Assured ?

Great question â€” this is exactly what interviewers and architects want to hear, not â€œWireMock is used to mock APIsâ€ ğŸ˜„
Letâ€™s talk real-time, real-project usage of WireMock with Rest Assured.

ğŸš€ When Is WireMock Used in Real-Time Use Cases (Rest Assured)

Think of WireMock as a controlled stand-in for unstable, expensive, slow, or unavailable dependencies.

1ï¸âƒ£ Third-Party API Dependencies (Most Common)
ğŸ§  Problem

Payment gateways

SMS / Email providers

Fraud / Credit score services

OAuth / SSO providers

ğŸ‘‰ These are:

Paid

Rate-limited

Unstable

Hard to control test data

âœ… Real-Time Use Case

Mock third-party APIs using WireMock while testing your service logic.

Example
stubFor(post(urlEqualTo("/payment"))
    .willReturn(aResponse()
        .withStatus(200)
        .withBody("{\"status\":\"SUCCESS\"}")));


Rest Assured tests your service:

given()
.when()
    .post("/checkout")
.then()
    .statusCode(200);


âœ” Safe
âœ” Fast
âœ” Deterministic

2ï¸âƒ£ Test Environment Not Ready / Down
ğŸ§  Problem

Backend service not deployed

Dependent microservice unstable

Feature under development

âœ… Use Case

QA continues testing by mocking missing services.

Shift-left testing

3ï¸âƒ£ Negative & Edge Case Testing (Hard to Reproduce in Real Systems)
Examples

500 Internal Server Error

Timeout

Invalid response schema

Slow responses

Corrupted payloads

WireMock Example
stubFor(get(urlEqualTo("/inventory"))
    .willReturn(aResponse()
        .withFixedDelay(8000)
        .withStatus(504)));


âœ” Validates retry logic
âœ” Circuit breaker testing

4ï¸âƒ£ Contract Testing Between Microservices
ğŸ§  Problem

Breaking changes between teams

âœ… Use Case

WireMock acts as consumer-driven contract provider

stubFor(get(urlEqualTo("/user/123"))
    .willReturn(okJson("{\"id\":123,\"name\":\"John\"}")));


âœ” Ensures API shape consistency
âœ” Prevents production breaks

5ï¸âƒ£ Rate Limiting & Throttling Validation
ğŸ§  Problem

Hard to hit rate limits reliably in real systems

WireMock Simulation
stubFor(get(urlEqualTo("/api"))
    .willReturn(aResponse().withStatus(429)));


âœ” Test retry/backoff logic
âœ” Validate client resilience

6ï¸âƒ£ Stateful Business Workflows
ğŸ§  Problem

Backend state is complex (order lifecycle, payments)

WireMock Scenario Example
.inScenario("OrderFlow")
.whenScenarioStateIs(STARTED)


âœ” Mimics real workflows
âœ” Enables API chaining

7ï¸âƒ£ CI/CD Stability & Speed
ğŸ§  Problem

CI flaky due to network issues

External API downtime

Slow execution

âœ… Use Case

Replace real dependencies with WireMock in CI.

â€œReal APIs in CI = flaky pipelinesâ€ âŒ

âœ” Fast
âœ” Reliable
âœ” Parallel-safe

8ï¸âƒ£ Security & Compliance Restrictions
ğŸ§  Problem

PII data access restrictions

Compliance limitations

No prod-like data in lower envs

âœ… Use Case

WireMock serves synthetic but realistic responses.

âœ” No sensitive data
âœ” Audit-friendly

9ï¸âƒ£ Controlled Test Data & Determinism
ğŸ§  Problem

Real APIs return unpredictable data

WireMock Fix
stubFor(get(urlEqualTo("/users"))
    .willReturn(okJson("{\"id\":1,\"name\":\"Test User\"}")));


âœ” Repeatable tests
âœ” No false failures

ğŸ”Ÿ Parallel & Load-Like Scenarios
ğŸ§  Problem

Concurrent calls produce inconsistent behavior

WireMock Advantage

No backend contention

Predictable responses

âœ” Ideal for parallel Rest Assured runs

ğŸ” When NOT to Use WireMock
Scenario	Why
End-to-end prod validation	Real APIs required
Performance testing	WireMock â‰  real latency
Data accuracy validation	Mock â‰  truth
Final release sign-off	Needs real systems
ğŸ§  Real Project Strategy (Senior Level)
Environment	Strategy
Local dev	WireMock only
QA	Hybrid (WireMock + real)
CI	WireMock heavy
Staging	Mostly real
Prod	No WireMock
ğŸ¯ Interview-Ready One-Liner

â€œWireMock is used in real-time Rest Assured testing to isolate external dependencies, simulate failure and edge scenarios, enable contract testing, and stabilize CI pipelines by providing fast, deterministic, and controllable API behavior.â€

ğŸ”¥ Bonus: WireMock + Rest Assured Together
@BeforeAll
static void setup() {
    wireMockServer.start();
    configureFor("localhost", 8080);
}