Advanced WireMock Mocking Features (With Code)
1ï¸âƒ£ Stateful Mocking (Scenario-Based Responses)
ğŸ“Œ Use Case

API behaves differently based on state (order lifecycle, payment flow).

Example

POST /order â†’ CREATED â†’ PAID

stubFor(post(urlEqualTo("/order"))
    .inScenario("Order Lifecycle")
    .whenScenarioStateIs(STARTED)
    .willSetStateTo("CREATED")
    .willReturn(aResponse()
        .withStatus(201)
        .withBody("{ \"status\": \"CREATED\" }")));

stubFor(post(urlEqualTo("/order/pay"))
    .inScenario("Order Lifecycle")
    .whenScenarioStateIs("CREATED")
    .willSetStateTo("PAID")
    .willReturn(aResponse()
        .withStatus(200)
        .withBody("{ \"status\": \"PAID\" }")));


âœ” Simulates real backend workflows
âœ” Perfect for API chaining tests

2ï¸âƒ£ Dynamic Responses with Response Templating
ğŸ“Œ Use Case

Return dynamic values like IDs, timestamps, headers.

Enable Templating
WireMockServer wireMockServer =
    new WireMockServer(options()
        .port(8080)
        .extensions(new ResponseTemplateTransformer(true)));

Example: Generate Dynamic Order ID
stubFor(post(urlEqualTo("/orders"))
    .willReturn(aResponse()
        .withHeader("Content-Type", "application/json")
        .withBody("""
        {
          "orderId": "{{randomValue length=10 type='ALPHANUMERIC'}}",
          "createdAt": "{{now}}"
        }
        """)
        .withTransformers("response-template")));


âœ” Removes hardcoding
âœ” CI-friendly

3ï¸âƒ£ Request Body Matching (Advanced Validation)
ğŸ“Œ Use Case

Mock behavior changes based on payload content.

Exact JSON Match
stubFor(post(urlEqualTo("/payment"))
    .withRequestBody(equalToJson("""
        { "method": "CREDIT_CARD" }
    """))
    .willReturn(ok()));

JSON Path Matching
stubFor(post(urlEqualTo("/payment"))
    .withRequestBody(matchingJsonPath("$.amount", greaterThan("1000")))
    .willReturn(aResponse()
        .withStatus(402)
        .withBody("Payment requires approval")));


âœ” Conditional mocking
âœ” Business-rule simulation

4ï¸âƒ£ Header-Based & Query Param Matching
ğŸ“Œ Use Case

Auth, versioning, locale, feature flags.

stubFor(get(urlPathEqualTo("/users"))
    .withHeader("Authorization", matching("Bearer .*"))
    .withQueryParam("version", equalTo("v2"))
    .willReturn(okJson("{ \"user\": \"premium\" }")));


âœ” Mimics real API gateways

5ï¸âƒ£ Fault Injection (Chaos Testing)
ğŸ“Œ Use Case

Test client resilience, retries, timeouts.

Network Faults
stubFor(get(urlEqualTo("/inventory"))
    .willReturn(aResponse()
        .withFault(Fault.CONNECTION_RESET_BY_PEER)));

Random Delay
stubFor(get(urlEqualTo("/slow-api"))
    .willReturn(aResponse()
        .withFixedDelay(5000)
        .withStatus(200)));


âœ” Retry logic validation
âœ” Circuit breaker testing

6ï¸âƒ£ Rate Limiting Simulation
ğŸ“Œ Use Case

Validate 429 handling.

AtomicInteger counter = new AtomicInteger(0);

stubFor(get(urlEqualTo("/rate-limited"))
    .willReturn(aResponse()
        .withTransformers("response-template")
        .withBody("""
        {{#if (gt (increment) 5)}}
          {{jsonPath request.body '$'}}
        {{/if}}
        """)));


ğŸ‘‰ Better approach (custom transformer):

public class RateLimitTransformer extends ResponseTransformer {

    private static final AtomicInteger COUNT = new AtomicInteger(0);

    @Override
    public Response transform(Request req, Response res, FileSource fs, Parameters p) {
        if (COUNT.incrementAndGet() > 5) {
            return Response.response()
                    .status(429)
                    .body("Too Many Requests")
                    .build();
        }
        return Response.response().status(200).body("OK").build();
    }

    @Override
    public String getName() {
        return "rate-limit-transformer";
    }
}

7ï¸âƒ£ Webhooks & Async Callback Simulation
ğŸ“Œ Use Case

Payment gateways, async notifications.

stubFor(post(urlEqualTo("/payments"))
    .willReturn(aResponse()
        .withStatus(202)
        .withBody("Accepted")));


Later:

stubFor(post(urlEqualTo("/callback"))
    .willReturn(ok()));


âœ” Simulates async systems

8ï¸âƒ£ Proxying to Real Service (Hybrid Mode)
ğŸ“Œ Use Case

Mock unstable dependencies, pass others.

stubFor(any(anyUrl())
    .willReturn(aResponse()
        .proxiedFrom("https://real-api.example.com")));


âœ” Gradual test environment isolation

9ï¸âƒ£ Verify Requests (Behavior Verification)
ğŸ“Œ Use Case

Ensure API was called correctly.

verify(postRequestedFor(urlEqualTo("/orders"))
    .withRequestBody(matchingJsonPath("$.product")));


âœ” Contract validation
âœ” Prevents silent failures

ğŸ”Ÿ Reset & Test Isolation
@AfterEach
void resetMocks() {
    wireMockServer.resetAll();
}


âœ” Clean test state
âœ” Parallel-safe

ğŸ§  Senior-Level Best Practices

âœ” Use WireMock for external dependencies only
âœ” Combine with Rest Assured for client-side assertions
âœ” Prefer Scenario + Templating over static stubs
âœ” Use faults for resilience testing
âœ” Never hardcode dynamic data

ğŸ¯ Interview-Ready Summary

â€œWireMock provides advanced mocking through stateful scenarios, dynamic response templating, conditional request matching, fault injection, and verification, enabling realistic simulation of complex backend behaviors for resilient API testing.â€

If you want next, I can:

ğŸ”¥ Show WireMock + Cucumber integration

ğŸ”¥ Build a rate-limit + retry test

ğŸ”¥ Demonstrate chaos testing with WireMock

ğŸ”¥ Design enterprise mocking strategy

Just say ğŸš€

---------------------------------------------------------------------------------------------------

When Wiremock is used in real time usecases in Rest Assured ?

Great question â€” this is exactly what interviewers and architects want to hear, not â€œWireMock is used to mock APIsâ€ ğŸ˜„
Letâ€™s talk real-time, real-project usage of WireMock with Rest Assured.

ğŸš€ When Is WireMock Used in Real-Time Use Cases (Rest Assured)

Think of WireMock as a controlled stand-in for unstable, expensive, slow, or unavailable dependencies.

1ï¸âƒ£ Third-Party API Dependencies (Most Common)
ğŸ§  Problem

Payment gateways

SMS / Email providers
Fraud / Credit score services
OAuth / SSO providers

ğŸ‘‰ These are:

Paid

Rate-limited

Unstable

Hard to control test data

âœ… Real-Time Use Case

Mock third-party APIs using WireMock while testing your service logic.

Example
stubFor(post(urlEqualTo("/payment"))
    .willReturn(aResponse()
        .withStatus(200)
        .withBody("{\"status\":\"SUCCESS\"}")));


Rest Assured tests your service:

given()
.when()
    .post("/checkout")
.then()
    .statusCode(200);


âœ” Safe
âœ” Fast
âœ” Deterministic

2ï¸âƒ£ Test Environment Not Ready / Down
ğŸ§  Problem

Backend service not deployed

Dependent microservice unstable

Feature under development

âœ… Use Case

QA continues testing by mocking missing services.

Shift-left testing

3ï¸âƒ£ Negative & Edge Case Testing (Hard to Reproduce in Real Systems)
Examples

500 Internal Server Error

Timeout

Invalid response schema

Slow responses

Corrupted payloads

WireMock Example
stubFor(get(urlEqualTo("/inventory"))
    .willReturn(aResponse()
        .withFixedDelay(8000)
        .withStatus(504)));


âœ” Validates retry logic
âœ” Circuit breaker testing

4ï¸âƒ£ Contract Testing Between Microservices
ğŸ§  Problem

Breaking changes between teams

âœ… Use Case

WireMock acts as consumer-driven contract provider

stubFor(get(urlEqualTo("/user/123"))
    .willReturn(okJson("{\"id\":123,\"name\":\"John\"}")));


âœ” Ensures API shape consistency
âœ” Prevents production breaks

5ï¸âƒ£ Rate Limiting & Throttling Validation
ğŸ§  Problem

Hard to hit rate limits reliably in real systems

WireMock Simulation
stubFor(get(urlEqualTo("/api"))
    .willReturn(aResponse().withStatus(429)));


âœ” Test retry/backoff logic
âœ” Validate client resilience

6ï¸âƒ£ Stateful Business Workflows
ğŸ§  Problem

Backend state is complex (order lifecycle, payments)

WireMock Scenario Example
.inScenario("OrderFlow")
.whenScenarioStateIs(STARTED)


âœ” Mimics real workflows
âœ” Enables API chaining

7ï¸âƒ£ CI/CD Stability & Speed
ğŸ§  Problem

CI flaky due to network issues

External API downtime

Slow execution

âœ… Use Case

Replace real dependencies with WireMock in CI.

â€œReal APIs in CI = flaky pipelinesâ€ âŒ

âœ” Fast
âœ” Reliable
âœ” Parallel-safe

8ï¸âƒ£ Security & Compliance Restrictions
ğŸ§  Problem

PII data access restrictions

Compliance limitations

No prod-like data in lower envs

âœ… Use Case

WireMock serves synthetic but realistic responses.

âœ” No sensitive data
âœ” Audit-friendly

9ï¸âƒ£ Controlled Test Data & Determinism
ğŸ§  Problem

Real APIs return unpredictable data

WireMock Fix
stubFor(get(urlEqualTo("/users"))
    .willReturn(okJson("{\"id\":1,\"name\":\"Test User\"}")));


âœ” Repeatable tests
âœ” No false failures

ğŸ”Ÿ Parallel & Load-Like Scenarios
ğŸ§  Problem

Concurrent calls produce inconsistent behavior

WireMock Advantage

No backend contention

Predictable responses

âœ” Ideal for parallel Rest Assured runs

ğŸ” When NOT to Use WireMock
Scenario										Why
End-to-end prod validation						Real APIs required
Performance testing								WireMock â‰  real latency
Data accuracy validation						Mock â‰  truth



Final release sign-off	Needs real systems

ğŸ§  Real Project Strategy (Senior Level)
Environment					Strategy
Local dev					WireMock only
QA							Hybrid (WireMock + real)
CI							WireMock heavy
Staging						Mostly real
Prod						No WireMock


ğŸ¯ Interview-Ready One-Liner

â€œWireMock is used in real-time Rest Assured testing to isolate external dependencies, simulate failure and edge scenarios, enable contract testing, and stabilize CI pipelines by providing fast, deterministic, and controllable API behavior.â€

ğŸ”¥ Bonus: WireMock + Rest Assured Together
@BeforeAll
static void setup() {
    wireMockServer.start();
    configureFor("localhost", 8080);
}



--------------------------------------------------------------------------------------------------------


Goal

Mock an external service that requires:

Authentication (who are you?)
Authorization (are you allowed?)
Using WireMock, so your:

Selenium / API tests
Microservice tests
CI pipelines

run without calling real external systems.

ğŸ§± High-Level Strategy

With WireMock, you:
Stub authentication behavior
Validate incoming auth details
Return appropriate responses

200 â†’ authorized
401 â†’ unauthenticated
403 â†’ unauthorized

WireMock doesnâ€™t enforce auth â€” you simulate it via request matching.

ğŸ” Auth Types You Can Mock with WireMock
Auth Type							Common In
Basic Auth							Legacy systems
Bearer Token (OAuth2 / JWT)			Modern APIs
API Key								SaaS integrations
mTLS (cert-based)					Banking / payments
Custom headers						Internal systems

Weâ€™ll cover all.

1ï¸âƒ£ Mocking Basic Authentication
Client sends:
Authorization: Basic base64(username:password)

WireMock Stub
stubFor(get(urlEqualTo("/external/accounts"))
    .withHeader("Authorization", equalTo("Basic dXNlcjpwYXNz"))
    .willReturn(aResponse()
        .withStatus(200)
        .withHeader("Content-Type", "application/json")
        .withBody("""
            {
              "accountId": "ACC123",
              "status": "ACTIVE"
            }
        """)));


ğŸ“Œ dXNlcjpwYXNz = base64(user:pass)

Unauthorized Case
stubFor(get(urlEqualTo("/external/accounts"))
    .atPriority(10)
    .willReturn(aResponse()
        .withStatus(401)
        .withBody("Unauthorized")));

Client Code (Rest Assured)
given()
    .auth().preemptive().basic("user", "pass")
.when()
    .get("/external/accounts")
.then()
    .statusCode(200);

2ï¸âƒ£ Mocking Bearer Token / OAuth2
Client sends:
Authorization: Bearer eyJhbGciOi...

WireMock Stub (Authorized)
stubFor(get(urlEqualTo("/external/payments"))
    .withHeader("Authorization", equalTo("Bearer valid-token-123"))
    .willReturn(aResponse()
        .withStatus(200)
        .withBody("""
            {
              "paymentId": "PAY123",
              "status": "SUCCESS"
            }
        """)));

Invalid Token â†’ 401
stubFor(get(urlEqualTo("/external/payments"))
    .atPriority(10)
    .willReturn(aResponse()
        .withStatus(401)
        .withBody("Invalid or missing token")));

Client Code
given()
    .header("Authorization", "Bearer valid-token-123")
.when()
    .get("/external/payments")
.then()
    .statusCode(200);

3ï¸âƒ£ Mocking Authorization (403 Forbidden)

Authentication â‰  Authorization

stubFor(get(urlEqualTo("/external/admin"))
    .withHeader("Authorization", equalTo("Bearer user-token"))
    .willReturn(aResponse()
        .withStatus(403)
        .withBody("Access Denied")));

Test Case
given()
    .header("Authorization", "Bearer user-token")
.when()
    .get("/external/admin")
.then()
    .statusCode(403);

4ï¸âƒ£ Mocking API Key Authentication
Client sends:
x-api-key: abc123

WireMock Stub
stubFor(post(urlEqualTo("/external/orders"))
    .withHeader("x-api-key", equalTo("abc123"))
    .willReturn(aResponse()
        .withStatus(201)
        .withBody("{ \"result\": \"ORDER_CREATED\" }")));

Missing API Key
stubFor(post(urlEqualTo("/external/orders"))
    .atPriority(10)
    .willReturn(aResponse()
        .withStatus(401)
        .withBody("API Key missing")));

5ï¸âƒ£ Mocking OAuth Token Endpoint (Very Important)

Most systems first call:

POST /oauth/token

WireMock Stub â€“ Token Generation
stubFor(post(urlEqualTo("/oauth/token"))
    .withRequestBody(containing("grant_type=client_credentials"))
    .willReturn(aResponse()
        .withStatus(200)
        .withHeader("Content-Type", "application/json")
        .withBody("""
            {
              "access_token": "valid-token-123",
              "token_type": "Bearer",
              "expires_in": 3600
            }
        """)));


ğŸ“Œ This lets you test full auth flow without real IdP.

6ï¸âƒ£ Mocking mTLS (Certificate-Based Auth)

WireMock canâ€™t validate certificates, but you simulate mTLS using headers injected by gateways:

stubFor(get(urlEqualTo("/secure/banking"))
    .withHeader("X-Client-Cert", matching(".*CN=trusted-client.*"))
    .willReturn(aResponse()
        .withStatus(200)
        .withBody("Authorized")));

7ï¸âƒ£ Verifying Auth Calls (Critical for Contracts)

verify(getRequestedFor(urlEqualTo("/external/payments"))
    .withHeader("Authorization", equalTo("Bearer valid-token-123")));


âœ” Confirms consumer sends auth correctly
âœ” Prevents silent auth regressions

ğŸ§ª Real CI/CD Usage Pattern
Consumer Tests
  â”œâ”€â”€ Start WireMock
  â”œâ”€â”€ Stub Auth Server
  â”œâ”€â”€ Stub External APIs
  â”œâ”€â”€ Run tests
  â””â”€â”€ Verify auth headers

ğŸ§  Best Practices (Enterprise Grade)

âœ… Store tokens / credentials in test config
âœ… Never hardcode real secrets
âœ… Use priority stubs for auth failures
âœ… Separate auth stubs from business stubs
âœ… Version control WireMock contracts

ğŸ§  Interview-Ready Explanation

â€œWe mock authenticated external services using WireMock by validating authorization headers, API keys, or tokens at request level. WireMock stubs act as both authentication and authorization contracts, allowing us to test consumer behavior under authorized, unauthorized, and forbidden scenarios without calling real external systems.â€

ğŸ§© WireMock vs Security Reality

Concern						WireMock
Real encryption				âŒ No
Auth behavior simulation	âœ” Yes
Contract validation			âœ” Yes
CI stability				â­â­â­â­â­

-------------------------------------------------------------

Example code - 



package Wiremock;

import com.github.tomakehurst.wiremock.WireMockServer;
import com.github.tomakehurst.wiremock.client.WireMock;
import io.restassured.RestAssured;
import io.restassured.response.Response;
import org.apache.http.impl.conn.Wire;

import static com.github.tomakehurst.wiremock.client.WireMock.*;

public class ContractTestPractice {

    public static WireMockServer wireMockServer;
    public static void wiremockSetup(){
        wireMockServer = new WireMockServer(7776);
        WireMock.configureFor("localhost", 7776);
        wireMockServer.start();
    }

    public static void tearDown(){
        wireMockServer.stop();
    }


    public static void contractForPaymentService(){

        stubFor(post(urlEqualTo("/payment/123"))
              .withHeader("Authorization", equalTo("BearerToken"))
//                .inScenario("ValidBearerToken")
                .atPriority(1)
                .willReturn(aResponse()
                        .withStatus(200)
                        .withHeader("Content-Type", "application/json")
                        .withBody("{\n" +
                                "                  \"orderId\": \"123\",\n" +
                                "                  \"status\": \"SUCCESS\",\n" +
                                "                  \"amount\": 4500\n" +
                                "                }")
                )
//                .willSetStateTo("ValidScenario")
        );

        stubFor(post(urlEqualTo("/payment/123"))
              .withHeader("Content-Type",equalTo("application/json"))
//                .inScenario("ValidScenario")
                .atPriority(10)
//                .whenScenarioStateIs("ValidScenario")
                .willReturn(aResponse()
                        .withStatus(403)
                        .withHeader("Content-Type", "application/json")
                        .withBody("BearerTOken Not present")
                        )
//                        .willSetStateTo("FINISHED")

        );

    }

    public static void main(String[] args) {
        wiremockSetup();
        contractForPaymentService();

        RestAssured.baseURI="http://localhost:7776";
        Response response = RestAssured.given().pathParam("id", "123")
                .header("Authorization","BearerToken")
                .post("/payment/{id}");
        System.out.println(response.getStatusCode());
        System.out.println(response.body().asString());


        Response response1 = RestAssured.given().pathParam("id", "123")
                .header("Authorization","InvalidBearerToken")
                .header("Content-Type","application/json")
                .post("/payment/{id}");
        System.out.println(response1.getStatusCode());
        System.out.println(response1.body().asString());

        tearDown();
    }
}
