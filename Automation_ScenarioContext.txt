Scenario Context Across Layers (Enterprise-Grade Design)
ğŸ§  What is Scenario Context?

Scenario Context is a per-scenario memory store used to:

Share data between steps

Avoid static variables

Avoid tight coupling between layers

Support parallel execution

ğŸ‘‰ Think of it as a ThreadLocal data backpack for a single scenario.

âŒ What Scenario Context is NOT

âŒ Not a global variable

âŒ Not a config store

âŒ Not a database

âŒ Not a replacement for Page Objects

ğŸ§± Where Scenario Context Lives (VERY IMPORTANT)

ğŸ“Œ Scenario Context belongs in the CORE layer

core
 â””â”€â”€ context
     â”œâ”€â”€ ScenarioContext
     â”œâ”€â”€ ContextKey (enum)
     â””â”€â”€ TestContext


Why?

Because it is cross-cutting infrastructure, not test logic.

ğŸ§© Core Layer Implementation
1ï¸âƒ£ ContextKey (Type Safety â€“ MUST HAVE)
public enum ContextKey {
    USER,
    TOKEN,
    ORDER_ID,
    USERS_LIST,
    RESPONSE
}


ğŸ“Œ Prevents "magic strings"

2ï¸âƒ£ ScenarioContext (Thread-Safe)
public class ScenarioContext {

    private final Map<ContextKey, Object> contextMap = new ConcurrentHashMap<>();

    public <T> void set(ContextKey key, T value) {
        contextMap.put(key, value);
    }

    public <T> T get(ContextKey key, Class<T> clazz) {
        return clazz.cast(contextMap.get(key));
    }

    public boolean contains(ContextKey key) {
        return contextMap.containsKey(key);
    }

    public void clear() {
        contextMap.clear();
    }
}

3ï¸âƒ£ TestContext (Dependency Carrier)
public class TestContext {

    private final ScenarioContext scenarioContext = new ScenarioContext();

    public ScenarioContext getScenarioContext() {
        return scenarioContext;
    }
}


ğŸ“Œ One TestContext per scenario (DI)

ğŸ”— How Context Flows Across Layers
Feature
 â†“
Step Definitions
 â†“
Business Steps
 â†“
Page Objects / API Clients
 â†“
Scenario Context (shared safely)

ğŸ§ª Step Definitions Layer (ONLY ENTRY POINT)
public class UserStepDefinitions {

    private final ScenarioContext scenarioContext;
    private final UserSteps userSteps;

    public UserStepDefinitions(TestContext testContext, UserSteps userSteps) {
        this.scenarioContext = testContext.getScenarioContext();
        this.userSteps = userSteps;
    }

    @Given("user is created via API")
    public void createUser() {
        User user = userSteps.createUser();
        scenarioContext.set(ContextKey.USER, user);
    }
}


ğŸ“Œ Only step definitions touch Scenario Context directly

ğŸ§  Business Steps Layer (Context-Aware, Not Context-Coupled)
public class UserSteps {

    private final UserApiClient userApi;

    public UserSteps(UserApiClient userApi) {
        this.userApi = userApi;
    }

    public User createUser() {
        return userApi.createUser();
    }
}


ğŸ“Œ Business steps return objects, they do NOT store them

ğŸ§± Page Objects Layer (Context-FREE ZONE ğŸš«)
public class DashboardPage {

    public String getWelcomeMessage() {
        return DriverManager.getDriver()
                .findElement(By.id("welcome"))
                .getText();
    }
}


ğŸ“Œ Page objects never know about Scenario Context

ğŸ§ª Reusing Context in Another Step
@Then("user should be visible on UI")
public void validateUserOnUI() {
    User user = scenarioContext.get(ContextKey.USER, User.class);
    dashboardPage.searchUser(user.getUsername());
}

ğŸ”¥ Advanced Example: API â†’ UI Flow
Step 1: API creates user
scenarioContext.set(ContextKey.USER_ID, userId);

Step 2: UI validates same user
String userId = scenarioContext.get(ContextKey.USER_ID, String.class);
uiSteps.searchUser(userId);

ğŸ§  Clearing Context (Important for Stability)
Cucumber Hook
@After
public void tearDown(TestContext testContext) {
    testContext.getScenarioContext().clear();
}


ğŸ“Œ Prevents memory leaks in long runs

ğŸš« Anti-Patterns (Senior Red Flags)

âŒ Static maps
âŒ String keys
âŒ Page Objects using context
âŒ Utils writing into context
âŒ Sharing context across scenarios

ğŸ¯ Interview-Ready Explanation (45 sec)

â€œScenario Context is a per-scenario data store used to safely share data across steps without tight coupling. It lives in the core layer, is accessed only by step definitions, and supports parallel execution via dependency injection and thread safety.â€

ğŸ§  One-Line Memory Hook

Context flows downward, never sideways.

ğŸ Senior Takeaway

A correct Scenario Context:

Makes tests readable

Keeps layers clean

Enables API-UI chaining

Prevents flaky parallel runs

If you want next:

ğŸ”¥ Scenario Context + Parallel Execution

ğŸ¯ Context vs Test Data Builders

ğŸ“Š Context misuse refactoring

ğŸ§  DI frameworks (PicoContainer / Spring)

Say the word ğŸ‘Š

ğŸ“Š Context misuse refactoring

Excellent topic ğŸ“Š â€” this is where senior engineers stand out.
Most flaky, tightly coupled automation frameworks suffer from Scenario Context misuse.

Iâ€™ll walk you through common misuses, why they hurt, and how to refactor them cleanly, with before/after code and decision rules.

ğŸ“Š Scenario Context Misuse â€” Refactoring Guide (Senior-Level)
ğŸ§  Core Rule (Burn This In)

Scenario Context is a courier, not a warehouse.

It should move data between steps, not become the frameworkâ€™s brain.

ğŸš¨ Common Scenario Context Misuses
âŒ Misuse #1: Page Objects Access Scenario Context
ğŸš« Problematic Code
public class DashboardPage {

    public void verifyUser() {
        User user = ScenarioContext.get("USER"); // âŒ
        driver.findElement(By.id("user")).sendKeys(user.getName());
    }
}

âŒ Why This Is Bad

Page Objects become test-aware

UI layer depends on Core layer

Violates SRP + DIP

Impossible to reuse page in other tests

âœ… Refactor (Correct Design)
public class DashboardPage {

    public void searchUser(String username) {
        driver.findElement(By.id("user")).sendKeys(username);
    }
}

User user = scenarioContext.get(ContextKey.USER, User.class);
dashboardPage.searchUser(user.getUsername());


ğŸ“Œ Context access only in Step Definitions

âŒ Misuse #2: Scenario Context Used as Global Variable
ğŸš« Problematic Code
public class ScenarioContext {
    public static Map<String, Object> data = new HashMap<>();
}

âŒ Why This Is Bad

Breaks parallel execution

Causes data leakage

Random test failures in CI

âœ… Refactor (Thread-Safe Context)
public class ScenarioContext {

    private final Map<ContextKey, Object> contextMap = new ConcurrentHashMap<>();

    public <T> void set(ContextKey key, T value) {
        contextMap.put(key, value);
    }
}


ğŸ“Œ One instance per scenario

âŒ Misuse #3: Overusing Context for Everything
ğŸš« Problematic Code
context.set("URL", "https://qa.site.com");
context.set("BROWSER", "chrome");
context.set("TIMEOUT", 30);

âŒ Why This Is Bad

Configuration â‰  Scenario data

Causes confusion

Hard to debug

âœ… Refactor (Proper Separation)
Data Type	Correct Place
URL	config.properties
Browser	CI parameter
User ID	Scenario Context
Token	Scenario Context
âŒ Misuse #4: String Keys Instead of Enums
ğŸš« Problematic Code
context.set("user", user);
context.get("User");

âŒ Why This Is Bad

Typos cause runtime failures

No IDE safety

Hard to refactor

âœ… Refactor (Enum Keys)
public enum ContextKey {
    USER,
    TOKEN,
    ORDER_ID
}

context.set(ContextKey.USER, user);

âŒ Misuse #5: Business Steps Writing to Context
ğŸš« Problematic Code
public void createUser() {
    User user = api.createUser();
    scenarioContext.set(ContextKey.USER, user); // âŒ
}

âŒ Why This Is Bad

Business logic becomes framework-aware

Tight coupling

Hard to unit test

âœ… Refactor (Return Objects)
public User createUser() {
    return api.createUser();
}

User user = userSteps.createUser();
scenarioContext.set(ContextKey.USER, user);

âŒ Misuse #6: Context Used Across Scenarios
ğŸš« Problematic Code
static ScenarioContext context;

âŒ Why This Is Bad

Cross-test pollution

Non-deterministic failures

âœ… Refactor (Lifecycle Management)
@After
public void tearDown(TestContext testContext) {
    testContext.getScenarioContext().clear();
}

ğŸ”¥ Real Refactoring Case Study
BEFORE (Messy)

Page objects read context

Static context

String keys

Business steps mutate context

AFTER (Clean)

Context only in step definitions

Enum keys

Business steps return data

Page objects are pure UI

ğŸ“‰ Flaky failures drop
ğŸ“ˆ Parallel stability improves
ğŸ“ˆ Readability improves

ğŸ§  Decision Matrix: Should This Go in Context?
Question	If YES	If NO
Needed in another step?	Context	Local variable
Config value?	Config file	âŒ Context
Test data object?	Context	âŒ Page
Temporary calculation?	Local	âŒ Context
ğŸ¯ Interview-Ready Answer (45 sec)

â€œScenario Context misuse usually happens when itâ€™s treated like a global store. I refactor by restricting context access to step definitions, using enum keys, making it thread-safe, and ensuring business and page layers remain context-agnostic. This greatly improves maintainability and parallel execution stability.â€

ğŸ§  One-Line Memory Hook

If everything goes into context, nothing is contextual.

ğŸ Senior Takeaway

Scenario Context is powerful â€” but dangerous if abused.
Use it sparingly, intentionally, and only at the boundaries.