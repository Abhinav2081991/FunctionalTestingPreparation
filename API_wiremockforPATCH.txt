What does PATCH mean in contract testing?

PATCH = partial update, so contracts usually validate:

HTTP method = PATCH

Path + path params

Headers (Authorization, Content-Type)

Partial request body (only changed fields)

Response body (updated state / acknowledgment)

WireMock is perfect for this because it supports:

JSONPath matching

Header matching

Body pattern matching

Priority & fallback stubs

ğŸ”¹ Basic WireMock PATCH Stub (Minimal)
stubFor(patch(urlEqualTo("/users/123"))
    .willReturn(aResponse()
        .withStatus(200)
        .withHeader("Content-Type", "application/json")
        .withBody("{\"message\":\"User updated successfully\"}")
    )
);


âœ” Works, but too weak for real contracts.

ğŸ”¹ Realistic PATCH Contract (Recommended)
Scenario

Update only email and status of a user.

âœ… WireMock PATCH Stub (With Validation)
stubFor(patch(urlPathMatching("/users/\\d+"))
    .withHeader("Authorization", equalTo("Bearer valid-token"))
    .withHeader("Content-Type", containing("application/json"))

    // âœ… Validate partial fields
    .withRequestBody(matchingJsonPath("$.email"))
    .withRequestBody(matchingJsonPath("$.status"))

    .atPriority(1)
    .willReturn(aResponse()
        .withStatus(200)
        .withHeader("Content-Type", "application/json")
        .withBody(
            "{\n" +
            "  \"id\": 123,\n" +
            "  \"email\": \"updated@mail.com\",\n" +
            "  \"status\": \"ACTIVE\",\n" +
            "  \"updated\": true\n" +
            "}"
        )
    )
);

âŒ Fallback Stub (Invalid PATCH)
stubFor(patch(urlPathMatching("/users/\\d+"))
    .atPriority(10)
    .willReturn(aResponse()
        .withStatus(400)
        .withHeader("Content-Type", "application/json")
        .withBody("{\"error\":\"Invalid PATCH request\"}")
    )
);

ğŸ”¹ Rest Assured Client Call (PATCH)
RestAssured.baseURI = "http://localhost:7776";

String patchPayload =
        "{\n" +
        "  \"email\": \"updated@mail.com\",\n" +
        "  \"status\": \"ACTIVE\"\n" +
        "}";

Response response = RestAssured
        .given()
        .header("Authorization", "Bearer valid-token")
        .contentType("application/json")
        .body(patchPayload)
        .patch("/users/123");

System.out.println(response.getStatusCode());
System.out.println(response.getBody().asString());

ğŸ§ª Expected Output
{
  "id": 123,
  "email": "updated@mail.com",
  "status": "ACTIVE",
  "updated": true
}

ğŸ”¹ Advanced PATCH Matching (Very Real-World)
Validate field value (not just presence)
.withRequestBody(matchingJsonPath("$.status", equalTo("ACTIVE")))

Optional fields (PATCH-friendly)
.withRequestBody(matchingJsonPath("$.email", absentOrNull()))

Reject forbidden fields
.withRequestBody(notMatching(".*\"password\".*"))

ğŸ”¹ PATCH with Path + Query Params
stubFor(patch(urlPathEqualTo("/users/123"))
    .withQueryParam("soft", equalTo("true"))
    .willReturn(aResponse()
        .withStatus(200)
        .withBody("{\"softUpdated\":true}")
    )
);


Client:

.patch("/users/123?soft=true");

ğŸ”¹ PATCH vs PUT in Contract Testing (Interview Gold)
PATCH	PUT
Partial update	Full replacement
Fields optional	All fields required
Safer for backward compatibility	Risky if contract changes
JSONPath validation	Full body validation
ğŸ”¹ Best Practices for PATCH in WireMock

âœ” Use matchingJsonPath() (not full body match)
âœ” Validate only changed fields
âœ” Always add fallback stub
âœ” Use priorities
âœ” Avoid scenarios unless stateful workflow

ğŸ§  Interview-Ready One-Liner

â€œFor PATCH contracts in WireMock, I validate only the partial fields using JSONPath matchers instead of full body matching, ensuring backward compatibility and stable consumer contracts.â€

ğŸš€ Want Next?

I can show:

PATCH + ETag / If-Match

PATCH with JWT claim validation

PATCH negative test matrix

PATCH Cucumber step definitions

PATCH contract â†’ PACT migration

Just say the word ğŸ‘Œ

How to add Jsonschemavalidation in this ?

Perfect follow-up ğŸ‘
JSON Schema validation is exactly what takes your WireMock + Rest Assured contract tests from â€œworksâ€ to â€œenterprise-gradeâ€.

Iâ€™ll show you how to add it cleanly, where it belongs, and why this is the right design.

ğŸ”¹ Where JSON Schema Validation fits in Contract Testing

WireMock

Validates request contract

Controls response behavior

Rest Assured

Validates response contract

Ensures structure, types, required fields

â¡ï¸ Schema validation ALWAYS happens on the consumer side (Rest Assured)
WireMock does not validate schemas â€” it stubs responses.

ğŸ”¹ Step 1: Add Maven Dependency
<dependency>
    <groupId>io.rest-assured</groupId>
    <artifactId>json-schema-validator</artifactId>
    <version>5.4.0</version>
    <scope>test</scope>
</dependency>


âš ï¸ Version should match your Rest Assured version.

ğŸ”¹ Step 2: Create JSON Schema

ğŸ“ src/test/resources/schemas/user_patch_response.schema.json

{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "required": ["id", "email", "status", "updated"],
  "properties": {
    "id": {
      "type": "integer"
    },
    "email": {
      "type": "string",
      "format": "email"
    },
    "status": {
      "type": "string",
      "enum": ["ACTIVE", "INACTIVE"]
    },
    "updated": {
      "type": "boolean"
    }
  },
  "additionalProperties": false
}


âœ” Enforces exact contract
âœ” Prevents accidental field leaks
âœ” Perfect for CI/CD

ğŸ”¹ Step 3: WireMock Stub (Same as Before)
stubFor(patch(urlPathMatching("/users/\\d+"))
    .withHeader("Authorization", equalTo("Bearer valid-token"))
    .withHeader("Content-Type", containing("application/json"))
    .withRequestBody(matchingJsonPath("$.email"))
    .withRequestBody(matchingJsonPath("$.status"))
    .willReturn(aResponse()
        .withStatus(200)
        .withHeader("Content-Type", "application/json")
        .withBody(
            "{\n" +
            "  \"id\": 123,\n" +
            "  \"email\": \"updated@mail.com\",\n" +
            "  \"status\": \"ACTIVE\",\n" +
            "  \"updated\": true\n" +
            "}"
        )
    )
);

ğŸ”¹ Step 4: Rest Assured + JSON Schema Validation
import static io.restassured.module.jsv.JsonSchemaValidator.matchesJsonSchemaInClasspath;
import static org.hamcrest.Matchers.*;

String patchPayload =
        "{\n" +
        "  \"email\": \"updated@mail.com\",\n" +
        "  \"status\": \"ACTIVE\"\n" +
        "}";

RestAssured
    .given()
        .header("Authorization", "Bearer valid-token")
        .contentType("application/json")
        .body(patchPayload)
    .when()
        .patch("/users/123")
    .then()
        .statusCode(200)
        .body(matchesJsonSchemaInClasspath(
            "schemas/user_patch_response.schema.json"
        ));


âœ” Structure validated
âœ” Data types validated
âœ” Required fields enforced
âœ” Extra fields rejected

ğŸ”¹ Step 5: Negative Contract Example (Very Important)
WireMock returns extra field (accidental change)
{
  "id": 123,
  "email": "updated@mail.com",
  "status": "ACTIVE",
  "updated": true,
  "debug": "internal"
}


âŒ Test will FAIL because:

"additionalProperties": false


ğŸ’¥ This is how contract drift is caught early

ğŸ”¹ PATCH + Optional Fields Schema (Advanced)

PATCH often has optional fields, response still strict.

"email": { "type": ["string", "null"] }

ğŸ”¹ Validate Array Responses (Bonus)
{
  "type": "array",
  "items": {
    "$ref": "user_patch_response.schema.json"
  }
}

ğŸ”¹ Best Practices (Real Projects)

âœ” One schema per endpoint
âœ” Version schemas (v1, v2)
âœ” Store schemas in Git
âœ” Run in CI (fail fast)
âœ” Never inline schemas in code

ğŸ§  Interview-Grade Summary

â€œWireMock validates request contracts, Rest Assured validates response contracts using JSON Schema. This separation ensures maintainable, backward-compatible API testing and prevents contract drift in CI/CD.â€