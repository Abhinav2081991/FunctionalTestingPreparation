ğŸ” What a true Singleton is

A classic Singleton has all 3 guarantees:

Exactly one instance of the class

Private constructor

Controlled access to that single instance

Example (textbook):

public class ClassicSingleton {

    private static final ClassicSingleton INSTANCE = new ClassicSingleton();

    private ClassicSingleton() {}

    public static ClassicSingleton getInstance() {
        return INSTANCE;
    }
}

ğŸ§ª Now analyze your DriverManager
public final class DriverManager {

    public static ThreadLocal<WebDriver> threadLocalDriver = new ThreadLocal<>();

    private DriverManager() {}

    public static WebDriver getDriver() {
        return threadLocalDriver.get();
    }

    public static void setDriver(WebDriver driver) {
        threadLocalDriver.set(driver);
    }

    public static void unload() {
        threadLocalDriver.remove();
    }
}

âœ… What makes it look like a Singleton

âœ” Private constructor
âœ” Final class
âœ” Global access via static methods
âœ” Single â€œmanagerâ€ role

â¡ This matches the intent of Singleton (centralized access)

âŒ Why it is NOT a true Singleton
ğŸš« There is no instance of DriverManager

Everything is static

No getInstance()

No object lifecycle

DriverManager dm = new DriverManager(); // impossible, but also unnecessary


So technically:

No object â†’ no singleton instance

ğŸ§  What this pattern ACTUALLY is
âœ… Singleton-style Utility Class

Sometimes called:

Static Holder Pattern

Driver Context

Thread-Scoped Resource Manager

ğŸ‘‰ Very common in Selenium frameworks
ğŸ‘‰ Purpose is driver lifecycle control, not object instantiation

ğŸ§µ Why ThreadLocal changes the game
public static ThreadLocal<WebDriver> threadLocalDriver = new ThreadLocal<>();


This means:

One WebDriver per thread

But still ONE global access point

So effectively:

Singleton per thread, not per JVM

This is exactly what you want in:

Parallel execution

Selenium Grid

Jenkins multi-node runs

ğŸ§© Pattern Classification (Interview-grade)
Question	Answer
Is this a Singleton?	âŒ Not strictly
Does it follow Singleton intent?	âœ… Yes
What pattern is this?	Static Utility + ThreadLocal
Why used in Selenium?	Thread-safe driver access
ğŸ¯ Interview-Perfect Answer

â€œThis is not a classical Singleton because no instance is created. Itâ€™s a static utility class that provides centralized, thread-safe access to WebDriver using ThreadLocal. Conceptually it behaves like a Singleton per thread, which is ideal for parallel Selenium execution.â€

ğŸ”¥ BONUS: If you want a true Singleton + ThreadLocal
public final class DriverManager {

    private static final DriverManager INSTANCE = new DriverManager();
    private ThreadLocal<WebDriver> driver = new ThreadLocal<>();

    private DriverManager() {}

    public static DriverManager getInstance() {
        return INSTANCE;
    }

    public WebDriver getDriver() {
        return driver.get();
    }

    public void setDriver(WebDriver webDriver) {
        driver.set(webDriver);
    }
}


â¡ But most frameworks DONâ€™T need this â€” your version is cleaner.

ğŸ§  Senior Insight

In Selenium frameworks, clarity and thread safety matter more than textbook patterns.

Your implementation is correct, industry-standard, and CI-safe.